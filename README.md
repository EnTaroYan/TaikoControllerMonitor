# ESP32 前四路示波器上位机

这是一个用Python编写的示波器上位机程序，用于接收ESP32通过串口发送的8路int32数据，并实时显示前4路波形。程序支持二进制数据包解析、可配置的数据打印控制和精确到毫秒的时间戳。

## 功能特点

- 🔌 自动扫描和选择COM端口
- ⚙️ 可配置串口参数（波特率）
- 📊 显示前4路波形数据（通道1-4），8路数据完整接收
- 🎨 每路波形使用不同颜色显示
- 📈 实时数据更新（支持高采样率）
- 🧹 数据清除功能
- 📱 现代化的用户界面
- ⏰ 精确到毫秒的时间戳显示
- 🎛️ 可配置的数据打印控制（跳过检查掩码）
- 📋 格式化的数据显示输出（[000,000,000,000,000,000,000,000]格式）
- 🔍 二进制数据包解析，支持帧头帧尾校验

## 安装依赖

首先确保您已安装Python 3.7或更高版本，然后安装所需的依赖包：

```bash
pip install -r requirements.txt
```

或者手动安装：

```bash
pip install pyserial PyQt5 pyqtgraph numpy
```

## 数据格式

ESP32发送的数据包格式为二进制数据包，结构如下：
```
帧头(0x55) + 8个int32数据 + 帧尾(0xAA)
```

- **帧头**：固定为0x55（1字节）
- **数据部分**：8个int32类型的数据，采用小端字节序（32字节）
- **帧尾**：固定为0xAA（1字节）
- **总长度**：34字节

### 数据包结构图
```
字节位置: 0    1-4     5-8     9-12    13-16   17-20   21-24   25-28   29-32   33
数据内容: 0x55  CH1     CH2     CH3     CH4     CH5     CH6     CH7     CH8    0xAA
```

### 数据包示例
假设ESP32发送数据：`[1024, -512, 2048, -1024, 512, -256, 128, -64]`

二进制数据包构成：
```
帧头: 0x55 (1字节)
数据: struct.pack('<8i', 1024, -512, 2048, -1024, 512, -256, 128, -64) (32字节)
帧尾: 0xAA (1字节)
```

### 波形显示说明
- **显示通道**：仅显示前4路波形（通道1-4）
- **数据接收**：完整接收8路数据，后4路不显示但参与数据处理
- **颜色区分**：
  - 通道1：红色 (#FF0000)
  - 通道2：绿色 (#00AA00)
  - 通道3：蓝色 (#0000FF)
  - 通道4：橙色 (#FF8800)

## 使用方法

### 1. 基本启动
```bash
python oscilloscope.py
```

### 2. 高级启动（带参数）
```bash
# 跳过检查第5通道的数据打印
python oscilloscope.py --skip-mask 0b00010000

# 跳过检查第5,6,7,8通道（只检查前4通道）
python oscilloscope.py --skip-mask 0b11110000

# 跳过检查第1,2,3,4通道（只检查后4通道）
python oscilloscope.py --skip-mask 0b00001111
```

### 3. 连接ESP32
- 将ESP32连接到电脑的USB端口
- 在程序中点击"刷新"按钮扫描可用端口
- 选择对应的COM端口
- 选择波特率（默认115200）
- 点击"连接"按钮

### 4. 查看波形
- 连接成功后，前4路波形将实时显示
- 每路波形使用不同颜色区分
- 可以调整显示点数（100-5000点）
- 支持自动缩放和手动清除数据

### 5. 数据输出格式
程序会根据设置的跳过检查掩码在控制台输出数据，格式如下：
```
[2025-01-15 14:30:25.123] 接收到数据: [000,512,999,***,000,000,000,000]
```

**输出格式说明：**
- **时间戳**：精确到毫秒，格式为`[YYYY-MM-DD HH:MM:SS.mmm]`
- **数据格式**：`[000,000,000,000,000,000,000,000]`（8个通道数据）
- **数值显示规则**：
  - 正常值：显示为3位数字（如：`001`、`512`）
  - 大于1000：显示为`999`
  - 小于-1000：显示为`-999`
  - 负数：显示为4位数字（如：`-001`、`-512`）
- **跳过检查标记**：跳过检查的通道显示为`***`

**数据打印触发条件：**
- 只有当未跳过检查的通道中有非零数据时才会打印
- 如果所有未跳过检查的通道数据都为0，则不会打印

## ESP32测试代码

项目中包含了一个ESP32测试程序`esp32_test_sender.ino`，它会生成8路不同的测试波形并按照新的数据包格式发送：

1. 通道1：正弦波
2. 通道2：余弦波  
3. 通道3：方波
4. 通道4：三角波
5. 通道5：锯齿波
6. 通道6：随机噪声
7. 通道7：低频正弦波
8. 通道8：高频正弦波

### 数据包发送格式
```cpp
// 构建数据包：帧头 + 8个int32 + 帧尾
uint8_t packet[34];
packet[0] = 0x55;  // 帧头
memcpy(&packet[1], data, 32);  // 8个int32数据
packet[33] = 0xAA;  // 帧尾
Serial.write(packet, 34);
```

### 上传测试代码到ESP32

1. 在Arduino IDE中打开`esp32_test_sender.ino`
2. 选择正确的开发板和端口
3. 上传代码到ESP32
4. 打开串口监视器确认数据正常发送

## 程序界面说明

### 左侧控制面板
- **端口选择**：显示所有可用的串口，点击刷新更新列表
- **波特率设置**：支持常用波特率（9600, 115200, 230400, 460800, 921600）
- **连接状态**：显示当前连接状态
- **显示设置**：调整显示的数据点数
- **清除数据**：清空所有波形显示
- **自动缩放**：自动调整Y轴范围以适应数据

### 右侧波形显示
- 显示前4个通道的波形（通道1-4）
- 每个通道使用不同颜色：
  - 通道1：红色
  - 通道2：绿色
  - 通道3：蓝色
  - 通道4：橙色
- X轴：时间（采样点）
- Y轴：幅值（支持手动和自动缩放）
- 支持网格显示和图例

### 控制台输出
- 实时显示接收到的数据
- 精确到毫秒的时间戳
- 格式化的数据显示
- 可配置的通道检查控制

## 命令行参数

### --skip-mask 参数详解
`--skip-mask`参数用于控制哪些通道跳过非零数据检查，支持两种格式：

#### 二进制格式（推荐）
```bash
python oscilloscope.py --skip-mask 0b00010000  # 跳过第5通道检查
python oscilloscope.py --skip-mask 0b11110000  # 跳过第5,6,7,8通道检查
python oscilloscope.py --skip-mask 0b00001111  # 跳过第1,2,3,4通道检查
python oscilloscope.py --skip-mask 0b10101010  # 跳过第2,4,6,8通道检查
```

#### 十进制格式
```bash
python oscilloscope.py --skip-mask 16   # 等同于0b00010000
python oscilloscope.py --skip-mask 240  # 等同于0b11110000
python oscilloscope.py --skip-mask 15   # 等同于0b00001111
python oscilloscope.py --skip-mask 170  # 等同于0b10101010
```

### 掩码原理
- **8位二进制掩码**：每一位对应一个通道（从右到左：第1位对应通道1，第8位对应通道8）
- **位值含义**：
  - `0`：检查该通道是否非零，如果非零则触发数据打印
  - `1`：跳过该通道的非零检查，该通道在输出中显示为`***`
- **触发条件**：只有当未跳过检查的通道中有非零数据时才会打印整行数据

### 常用掩码模式
```bash
# 检查所有通道（默认）
python oscilloscope.py --skip-mask 0b00000000

# 只检查显示的前4个通道，忽略后4个通道
python oscilloscope.py --skip-mask 0b11110000

# 只检查奇数通道（1,3,5,7）
python oscilloscope.py --skip-mask 0b10101010

# 只检查偶数通道（2,4,6,8）
python oscilloscope.py --skip-mask 0b01010101

# 只检查第1通道
python oscilloscope.py --skip-mask 0b11111110

# 只检查第8通道
python oscilloscope.py --skip-mask 0b01111111
```

## 故障排除

### 1. 无法找到串口
- 确认ESP32已正确连接到电脑
- 检查驱动程序是否已安装
- 点击"刷新"按钮重新扫描端口

### 2. 连接失败
- 检查端口是否被其他程序占用
- 确认波特率设置正确
- 尝试不同的波特率

### 3. 无数据显示
- 检查ESP32是否正在发送数据
- 确认数据包格式是否正确（帧头0x55，帧尾0xAA，34字节长度）
- 检查数据是否为有效的int32格式
- 查看程序控制台是否有错误信息
- 检查跳过检查掩码设置是否正确

### 4. 波形显示异常
- 检查发送的数据是否在int32范围内（-2,147,483,648 到 2,147,483,647）
- 确认数据包格式正确（34字节：帧头1字节+数据32字节+帧尾1字节）
- 检查数据是否为小端字节序
- 尝试清除数据重新开始
- 使用自动缩放功能调整显示范围

### 5. 数据打印问题
- 检查`--skip-mask`参数设置是否正确
- 确认需要检查的通道有非零数据
- 查看控制台输出的掩码设置信息
- 验证数据包是否完整（帧头帧尾校验）

### 6. 帧头帧尾校验失败
- 检查ESP32发送的数据包格式
- 确认帧头为0x55，帧尾为0xAA
- 检查数据包总长度是否为34字节
- 验证数据传输是否有丢失或错误

## 自定义修改

### 修改显示通道数量
当前程序只显示前4个通道，如需显示更多通道：
1. 修改`OscilloscopeWidget.init_ui()`中的`colors`列表和曲线创建数量
2. 调整`_create_curves()`方法中的循环范围
3. 更新`update_data()`方法中的显示逻辑

### 修改数据包格式
如需支持不同的数据包格式：
1. 修改`DataReceiver._receive_loop()`中的数据包长度检查（当前为34字节）
2. 更新`_parse_data_packet()`中的解析逻辑
3. 调整ESP32发送代码中的数据包格式
4. 修改帧头帧尾校验逻辑

### 修改打印控制
如需调整数据打印行为：
1. 修改`_parse_data_packet()`中的打印条件逻辑
2. 调整数值显示格式和限制范围
3. 自定义跳过检查的掩码处理逻辑
4. 修改时间戳格式

### 添加数据保存功能
可以在`OscilloscopeMainWindow`中添加：
1. 实时数据记录功能
2. 文件保存对话框
3. CSV、JSON或其他格式的数据导出
4. 历史数据回放功能

### 修改数据处理精度
当前使用int32格式，如需更高精度：
1. 修改`struct.unpack('<8i', packet_data)`为相应格式
2. 调整ESP32端的数据类型
3. 更新数据包长度计算

## 性能优化

- **多线程数据接收**：使用独立线程接收串口数据，避免界面卡顿
- **智能缓冲管理**：采用字节缓冲队列存储数据，支持高速数据流处理
- **帧头帧尾校验**：二进制数据包解析，支持严格的帧头帧尾校验
- **可配置显示点数**：支持100-5000点可调，平衡性能和显示效果
- **精确时间戳**：毫秒级时间戳记录，便于数据分析和调试
- **智能数据过滤**：可配置的跳过检查掩码，减少无关数据输出
- **内存管理**：自动清理无效数据缓冲，防止内存溢出
- **错误处理**：完善的异常处理机制，确保程序稳定运行

## 技术规格

- **支持系统**：Windows, Linux, macOS
- **Python版本**：3.7+
- **数据格式**：int32（32位有符号整数）
- **数据包长度**：34字节（帧头1字节+数据32字节+帧尾1字节）
- **字节序**：小端字节序（Little Endian）
- **最大采样率**：取决于串口波特率和数据处理能力
- **最大显示点数**：5000点
- **显示通道数量**：4路（通道1-4）前端显示
- **数据接收通道**：8路（完整接收和处理）
- **时间戳精度**：毫秒级（±1ms）
- **支持的掩码模式**：8位二进制掩码控制
- **数据显示范围**：-999到999（超限值截断显示）
- **帧头标识**：0x55
- **帧尾标识**：0xAA

## 许可证

本项目采用MIT许可证，详见LICENSE文件。

## 贡献

欢迎提交问题和改进建议！
